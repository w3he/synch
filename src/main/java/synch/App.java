/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package synch;

import java.util.ArrayList;
import java.util.List;

public class App {

    public static void main(String[] args) {
        long started = System.currentTimeMillis();
        int scenario = Integer.parseInt(args[0]);
        int threads = Integer.parseInt(args[1]);
        int reps = Integer.parseInt(args[2]);
        List<Thread>allThreads = new ArrayList<>();
        switch (scenario) {
            case 1:

                for(int i=0; i < threads; i++) {
                    Thread t1 = new Thread(getRunner(reps));
                    t1.start();
                    allThreads.add(t1);
                }
                break;

            case 2:
                for(int i=0; i < threads; i++) {
                    Thread t2 = new Thread(getSynchRunner(reps));
                    t2.start();
                    allThreads.add(t2);
                }
                break;

            case 3:
            default:
                threads = threads / 2;
                for(int i=0; i < threads; i++) {
                    Thread t1 = new Thread(getRunner(reps));
                    Thread t2 = new Thread(getSynchRunner(reps));
                    t1.start();
                    t2.start();
                    allThreads.add(t1);
                    allThreads.add(t2);
                }
                break;
        }

        try {
            System.out.println("Wait for all threads to finish: " + allThreads.size());
            for(Thread t : allThreads) {
                t.join();
            }
        } catch (InterruptedException e) {
            System.err.println("We are interrupted. " + e.getLocalizedMessage());
        }

        System.out.println("It took (msec): " + (System.currentTimeMillis() - started));
        System.out.println("Final count: " + SynchCounter.getCount());
    }

    static Runnable getRunner(int N) {
        return new Runnable() {

            @Override
            public void run() {
                for(int i=0; i < N; i++) {
                    SynchCounter.add(1);
                }
                SynchCounter.sub(N);
            }
        };
    }

    static Runnable getSynchRunner(int N) {
        return new Runnable() {
            @Override
            public void run() {
                for(int i=0; i < N; i++) {
                    SynchCounter.addSynch(1);
                }
                SynchCounter.subSynch(N);
            }
        };
    }
}
